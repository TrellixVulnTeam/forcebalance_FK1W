\section gen_option_index Option index: General options

This section contains a listing of the general options available when running
a ForceBalance job, which go into the $options section.  The general options
are global for the ForceBalance job, in contrast to 'Target options' which apply to one
target within a job (described in the next section).
The option index is generated by running make-option-index.py.

@li <b> ADAPTIVE_DAMPING </b> (Float)
\n<b> Need to document </b>

@li <b> ADAPTIVE_FACTOR </b> (Float)
\n<b> Need to document </b>

@li <b> AMOEBA_POLARIZATION </b> (String)
\n<b> Need to document </b>

@li <b> ASYNCHRONOUS </b> (Bool)
\n<b> Need to document </b>

@li <b> BACKUP </b> (Bool)
\n<b> Scope </b>: All force field optimizations (Optional)
\n<b> One-line description </b>: 10
\n<b> Default Value </b>: 1

@li <b> CONSTRAIN_CHARGE </b> (Bool)
\n<b> Need to document </b>

@li <b> CONVERGENCE_GRADIENT </b> (Float)
\n<b> Scope </b>: Main optimizer (Optional)
\n<b> One-line description </b>: 100
\n<b> Full description </b>: The main optimizer will quit when the objective function gradient falls below this number.
                                          Since this is a newly implemented option, I can't say when this option will fail.
\n<b> Default Value </b>: 0.0001
\n<b> Recommendation </b>: Leave at the default, or set to several orders of magnitude below a typical value of the gradient (perhaps the gradient at the start of the optimization.)

@li <b> CONVERGENCE_OBJECTIVE </b> (Float)
\n<b> Scope </b>: Main optimizer (Optional)
\n<b> One-line description </b>: 100
\n<b> Full description </b>: The main optimizer will quit when the last ten good values of the objective function have a
                                           standard deviation that falls below this number.  We use the last ten good values (instead of the latest
                                           change in the objective function), otherwise this condition would be triggered by taking tiny steps.
\n<b> Default Value </b>: 0.0001
\n<b> Recommendation </b>: Decrease this value if it's being triggered by small step sizes.

@li <b> CONVERGENCE_STEP </b> (Float)
\n<b> Scope </b>: Main optimizer (Optional)
\n<b> One-line description </b>: 100
\n<b> Full description </b>: The main optimizer will quit when the step size falls below this number.  This happens if we are
                                      approaching a local minimum, or if the optimizer is constantly taking bad steps and the trust radius is
                                      reduced until it falls below this number.  In the latter case, this usually means that the derivatives are
                                      wrong.
\n<b> Default Value </b>: 0.0001
\n<b> Recommendation </b>: Make sure that this value is much smaller than trust0.

@li <b> EIG_LOWERBOUND </b> (Float)
\n<b> Scope </b>: Main optimizer (Optional)
\n<b> One-line description </b>: 10
\n<b> Full description </b>: The main optimizer will misbehave if there are negative or very small eigenvalues in the
                                    objective function Hessian.  In the former case the optimizer will travel toward a saddle point (or
                                    local maximum), and in the latter case the matrix inversion will fail because of the matrix singularity.
                                    If the smallest eigenvalue is below this value, then a multiple of the identity matrix is added to the
                                    Hessian to increase the smallest eigenvalue to at least this value.
\n<b> Default Value </b>: 0.0001
\n<b> Recommendation </b>: Shouldn't have to worry about this setting, unless the optimizer appears to be taking bad steps or inverting nearly singular matrices.

@li <b> ERROR_TOLERANCE </b> (Float)
\n<b> Need to document </b>

@li <b> FFDIR </b> (String)
\n<b> Scope </b>: All force field optimizations (Optional)
\n<b> One-line description </b>: 100
\n<b> Default Value </b>: forcefield
\n<b> Recommendation </b>: Unless you're using a nonstandard location for force field files, you probably shouldn't change this.

@li <b> FINITE_DIFFERENCE_H </b> (Float)
\n<b> Scope </b>: fdcheck_G or fdcheck_H job types, or whenever the objective function is evaluated using finite difference (Optional)
\n<b> One-line description </b>: 50
\n<b> Full description </b>: When the objective function derivatives are checked using finite difference, or when the objective function derivative
                                         requires finite difference, this is the step size that is used (in the mathematical space).  The actual parameter in the
                                         force field is changed by this amount times the rescaling factor.
\n<b> Default Value </b>: 0.001
\n<b> Recommendation </b>: 1e-2 to 1e-4; run FDCheckG to see if derivatives are accurate; if derivatives are inaccurate then adjust accordingly.
                                         If the objective function itself requires finite difference, there will still be a difference because FDCheckG(H) uses an accurate
                                         seven-point (five-point) stencil.  Make sure that the derivatives agree before settling on a value to use.

@li <b> FORCEFIELD </b> (List)
\n<b> Scope </b>: All force field optimizations (<b><em>Required</em></b>)
\n<b> One-line description </b>: 200
\n<b> Default Value </b>: []

@li <b> GMXPATH </b> (String)
\n<b> Scope </b>: Targets that use GROMACS (<b><em>Required</em></b>)
\n<b> One-line description </b>: 60
\n<b> Full description </b>: Specify the path where GROMACS executables are installed, most likely ending in 'bin'.
                             Note that executables are only installed 'bin' if the program is installed using 'make install';
                             this will NOT be the case if you simply ran 'make'.
\n<b> Default Value </b>: /home/leeping/opt/gromacs-4.5.5/bin
\n<b> Recommendation </b>: Depends on your local installation and environment.

@li <b> GMXSUFFIX </b> (String)
\n<b> Scope </b>: Targets that use GROMACS (Optional)
\n<b> One-line description </b>: 60
\n<b> Full description </b>: Depending on how GROMACS is configured and installed, a suffix may be appended to executable
                               names.  If there is a suffix, it needs to be specified here (or else ForceBalance will not find the
                               GROMACS executable and it will crash.
\n<b> Default Value </b>: 
\n<b> Recommendation </b>: Depends on your local installation and environment.

@li <b> HAVE_VSITE </b> (Bool)
\n<b> Need to document </b>

@li <b> JOBTYPE </b> (Allcap)
\n<b> Scope </b>: All force field optimizations (<b><em>Required</em></b>)
\n<b> One-line description </b>: 200
\n<b> Full description </b>: Here you may specify the type of ForceBalance job.  This ranges from gradient-based and stochastic
                             optimizations to simple scans over the parameter space and finite difference checking of gradients.
\n<b> Default Value </b>: single
\n<b> Recommendation </b>: See the Optimizer class documentation for which optimizer is best suited for you.

@li <b> LM_GUESS </b> (Float)
\n<b> Need to document </b>

@li <b> LOGARITHMIC_MAP </b> (Bool)
\n<b> Need to document </b>

@li <b> MAXSTEP </b> (Int)
\n<b> Scope </b>: All iterative optimization jobs (Optional)
\n<b> One-line description </b>: 50
\n<b> Default Value </b>: 100
\n<b> Recommendation </b>: At least 100 optimization steps are recommended.

@li <b> MINTRUST </b> (Float)
\n<b> Need to document </b>

@li <b> NORMALIZE_WEIGHTS </b> (Bool)
\n<b> Need to document </b>

@li <b> OBJECTIVE_HISTORY </b> (Int)
\n<b> Need to document </b>

@li <b> PENALTY_ADDITIVE </b> (Float)
\n<b> Scope </b>: Objective function (Optional)
\n<b> One-line description </b>: 55
\n<b> Full description </b>: Add a penalty to the objective function (e.g. L2 or L1 norm) with this prefactor.
                                      Using an additive penalty requires an assessment of the order of magnitude of the objective function,
                                      but it is closer to the statistical concept of ridge or LASSO regression.
\n<b> Default Value </b>: 0.0
\n<b> Recommendation </b>: No recommendation; run a single-point calculation to choose a prefactor.  Consider 0.01
                                      for an objective function of order 1.

@li <b> PENALTY_ALPHA </b> (Float)
\n<b> Need to document </b>

@li <b> PENALTY_HYPERBOLIC_B </b> (Float)
\n<b> Need to document </b>

@li <b> PENALTY_MULTIPLICATIVE </b> (Float)
\n<b> Scope </b>: Objective function (Optional)
\n<b> One-line description </b>: 55
\n<b> Full description </b>: Multiply the objective function by (1+X) where X is this value.
                                            Using an multiplicative penalty works well for objective functions of any size but it is not
                                            equivalent to statistical regularization methods.
\n<b> Default Value </b>: 0.0
\n<b> Recommendation </b>: A value of 0.01 tends to keep the length of the parameter vector from exceeding 1.

@li <b> PENALTY_TYPE </b> (String)
\n<b> Scope </b>: All force field optimizations (Optional)
\n<b> One-line description </b>: 100
\n<b> Full description </b>: To prevent the optimization from changing the parameters too much, an additional penalty
                                  is applied to the objective function that depends linearly (L1) or quadratically (L2) on the norm
                                  of the parameter displacement vector.  L1 corresponds to LASSO regularization while L2 is known as
                                  Tikhonov regularization or ridge regression.
\n<b> Default Value </b>: L2
\n<b> Recommendation </b>: L2; tested and known to be working.  Implementation of L1 in progress.

@li <b> PRINT_GRADIENT </b> (Bool)
\n<b> Need to document </b>

@li <b> PRINT_HESSIAN </b> (Bool)
\n<b> Need to document </b>

@li <b> PRINT_PARAMETERS </b> (Bool)
\n<b> Need to document </b>

@li <b> PRIORS </b> (Section)
\n<b> Need to document </b>

@li <b> READ_MVALS </b> (Section)
\n<b> Scope </b>: All force field optimizations (Optional)
\n<b> One-line description </b>: 100
\n<b> Full description </b>: Read in mathematical parameters before starting the optimization.  There is a standardized syntax, given by:
@verbatim read_mvals
0 [ -2.9766e-01 ] : VDWSOW
1 [  2.2283e-01 ] : VDWTOW
2 [ -1.1138e-03 ] : BONDSBHWOW
3 [ -9.0883e-02 ] : BONDSKHWOW
\read_mvals @endverbatim
\n<b> Default Value </b>: None
\n<b> Recommendation </b>: If you run the main optimizer, it will print out this block at the very end for you to use and/or modify.

@li <b> READ_PVALS </b> (Section)
\n<b> Scope </b>: All force field optimizations (Optional)
\n<b> One-line description </b>: 100
\n<b> Full description </b>: Read in physical parameters before starting the optimization.  There is a standardized
                                syntax, given by:
@verbatim read_pvals
 0 [  2.9961e-01 ] : VDWSOW
 1 [  1.2009e+00 ] : VDWTOW
 2 [  9.5661e-02 ] : BONDSBHWOW
 3 [  4.1721e+05 ] : BONDSKHWOW
 \read_pvals @endverbatim
                                These are the actual numbers that go into the force field file, so note the large changes in magnitude.
\n<b> Default Value </b>: None
\n<b> Recommendation </b>: If you run the main optimizer, it will print out this block at the very end for you to use and/or modify.

@li <b> READCHK </b> (String)
\n<b> Scope </b>: Main optimizer (Optional)
\n<b> One-line description </b>: -50
\n<b> Full description </b>: The main optimizer has the ability to pick up where it left off by reading / writing checkpoint
                             files.  Here you may specify the checkpoint file to read in from a previous optimization run.  This is
                             equivalent to reading in stored parameter values, except the gradient and Hessian (which contains memory from previous
                             steps) is recorded too.
\n<b> Default Value </b>: None

@li <b> RIGID_WATER </b> (Bool)
\n<b> Need to document </b>

@li <b> SCAN_VALS </b> (String)
\n<b> Scope </b>: scan_mvals and scan_pvals job types (Optional)
\n<b> One-line description </b>: -100
\n<b> Full description </b>: This specifies a range of parameter values to scan in a uniform grid.  scan_mvals works in
                               the mathematical parameter space while scan_pvals works in the physical parameter space.  The syntax
                               is lower:step:upper .  Both lower and upper limits are included in the range.
\n<b> Default Value </b>: None
\n<b> Recommendation </b>: For scan_mvals, a range of values between -1 and +1 is recommended; for scan_pvals, choose values close to the physical parameter value.

@li <b> SCANINDEX_NAME </b> (List)
\n<b> Scope </b>: scan_mvals and scan_pvals job types (Optional)
\n<b> One-line description </b>: -100
\n<b> Full description </b>: ForceBalance assigns to each adjustable parameter a 'parameter name'.  By specifying
                                    this option, this tells the parameter scanner to locate the correct parameter with the specified name and then
                                    scan over it.
\n<b> Default Value </b>: []
\n<b> Recommendation </b>: Look at the printout from a single-point job to determine the parameter names.

@li <b> SCANINDEX_NUM </b> (List)
\n<b> Scope </b>: scan_mvals and scan_pvals job types (Optional)
\n<b> One-line description </b>: -100
\n<b> Full description </b>: ForceBalance assigns to each adjustable parameter a 'parameter number' corresponding to
                                   its position in the parameter vector.  This tells the parameter scanner which number to scan over.
\n<b> Default Value </b>: []
\n<b> Recommendation </b>: Look at the printout from a single-point job to decide which parameter number you wish to scan over.

@li <b> SEARCH_TOLERANCE </b> (Float)
\n<b> Need to document </b>

@li <b> TINKERPATH </b> (String)
\n<b> Scope </b>: Targets that use TINKER (<b><em>Required</em></b>)
\n<b> One-line description </b>: 60
\n<b> Default Value </b>: 
\n<b> Recommendation </b>: Depends on your local installation and environment.

@li <b> TRUST0 </b> (Float)
\n<b> Scope </b>: Main optimizer (Optional)
\n<b> One-line description </b>: 100
\n<b> Full description </b>: The main optimizer uses a trust radius which 'adapts' (i.e. increases or decreases) based on whether the last step
                            was a good or bad step.  'trust0' provides the starting trust radius, and the trust radius is not allowed to increase too much
                            from trust0.
\n<b> Default Value </b>: 0.1
\n<b> Recommendation </b>: Increase from the default if the optimizer takes many good steps but takes too long; decrease if the optimizer takes many bad steps.

@li <b> USE_PVALS </b> (Bool)
\n<b> Need to document </b>

@li <b> VERBOSE_OPTIONS </b> (Bool)
\n<b> Need to document </b>

@li <b> WQ_PORT </b> (Int)
\n<b> Need to document </b>

@li <b> WRITECHK </b> (String)
\n<b> Scope </b>: Main optimizer (Optional)
\n<b> One-line description </b>: -50
\n<b> Full description </b>: The main optimizer has the ability to pick up where it left off by reading / writing checkpoint
                              files.  Here you may specify the checkpoint file to write after the job is finished.
\n<b> Default Value </b>: None
\n<b> Recommendation </b>: Writing the checkpoint file is highly recommended.

@li <b> WRITECHK_STEP </b> (Bool)
\n<b> Scope </b>: Main optimizer when 'writechk' is turned on (Optional)
\n<b> One-line description </b>: -50
\n<b> Full description </b>: Write a checkpoint file every single step, not just after the job is finished.
\n<b> Default Value </b>: 1
\n<b> Recommendation </b>: Useful if you want to quit an optimization before it finishes and restart, but make sure you don't overwrite existing checkpoint files by accident.

\section tgt_option_index Option index: Target options

This section contains a listing of the target options available when running
a ForceBalance job, which go into the $tgt_opts section.  There can be multiple 
$tgt_opts sections in a ForceBalance input file, one for each target.

@li <b> ABSOLUTE </b> (Bool)
\n<b> Need to document </b>

@li <b> ALL_AT_ONCE </b> (Bool)
\n<b> Need to document </b>

@li <b> ANISOTROPIC_BOX </b> (Bool)
\n<b> Need to document </b>

@li <b> ATTENUATE </b> (Bool)
\n<b> Need to document </b>

@li <b> BATCH_FD </b> (Bool)
\n<b> Scope </b>: All target types (Optional)
\n<b> One-line description </b>: -150
\n<b> Full description </b>: This is a stub for future functionality.  When the flag is switched on, the jobs corresponding to finite
                              difference derivatives are evaluated in parallel on a distributed computing platform.
\n<b> Default Value </b>: 0

@li <b> CAUCHY </b> (Bool)
\n<b> Need to document </b>

@li <b> COVARIANCE </b> (Bool)
\n<b> Scope </b>: Force and energy matching (Optional)
\n<b> One-line description </b>: -100
\n<b> Full description </b>: The components of the energy and force contribution to the objective function are rescaled to be on the 
                                same footing when the objective function is optimized.  This can be done by dividing each component by its variance,
                                or by multiplying the energy-force polytensor by the inverse of the quantum energy-force covariance matrix.  The
                                latter method was proposed as a way to emphasize intermolecular interactions but it is unproven.
\n<b> Default Value </b>: 0
\n<b> Recommendation </b>: No recommendation; turn the covariance off if the number of snapshots is not much larger than
                                the number of coordinates.

@li <b> DIPOLE_DENOM </b> (Float)
\n<b> Need to document </b>

@li <b> DO_COSMO </b> (Bool)
\n<b> Need to document </b>

@li <b> ENERGY </b> (Bool)
\n<b> Need to document </b>

@li <b> ENERGY_DENOM </b> (Float)
\n<b> Need to document </b>

@li <b> ENERGY_UPPER </b> (Float)
\n<b> Need to document </b>

@li <b> FD_PTYPES </b> (List)
\n<b> Scope </b>: All target types (Optional)
\n<b> One-line description </b>: -100
\n<b> Full description </b>: To compute the objective function derivatives, some components may require numerical finite difference in the derivatives.
                             Here you may specify the parameter types that finite difference is applied to,
                             or write 'ALL' to take finite-difference derivatives in all parameter types.
\n<b> Default Value </b>: []
\n<b> Recommendation </b>: If you aren't sure, either use 'ALL' to do finite difference in each component (this is costly), or run a fdcheckG(H)
                             job with this option set to 'NONE' to check which analytic derivatives are missing.

@li <b> FDGRAD </b> (Bool)
\n<b> Scope </b>: All target types (Optional)
\n<b> One-line description </b>: -100
\n<b> Full description </b>: When this option is enabled, finite difference gradients will be enabled for selected parameter types 
                            (using the fd_ptypes option).  Gradients are computed using two-point finite difference of the objective function.
\n<b> Default Value </b>: 0
\n<b> Recommendation </b>: If analytic derivatives are implemented (and correct), then they are much faster than finite difference
                            derivatives.  Run the 'fdcheckG' routine with this option set to Off to check which finite difference derivatives you need.

@li <b> FDHESS </b> (Bool)
\n<b> Scope </b>: All target types (Optional)
\n<b> One-line description </b>: -100
\n<b> Full description </b>: When this option is enabled, finite difference Hessians will be enabled for selected parameter types 
                            (using the fd_ptypes option).  Hessians are computed using two-point finite difference of the gradient.
\n<b> Default Value </b>: 0
\n<b> Recommendation </b>: Run the 'fdcheckH' routine with this option set to Off to check which finite difference Hessian elements you need.
                            Note that this requires a very large number of objective function evaluations, so use sparingly.

@li <b> FDHESSDIAG </b> (Bool)
\n<b> Scope </b>: All target types (Optional)
\n<b> One-line description </b>: -100
\n<b> Full description </b>: When this option is enabled, finite difference gradients and Hessian diagonal elements will be enabled 
                                for selected parameter types (using the fd_ptypes option).  This is done using a three-point finite difference of
                                the objective function.
\n<b> Default Value </b>: 0
\n<b> Recommendation </b>: Use this as a substitute for 'fdgrad'; it doubles the cost but provides more accurate derivatives
                                plus the Hessian diagonal values (these are very nice for quasi-Newton optimizers like BFGS).

@li <b> FITATOMS </b> (Int)
\n<b> Scope </b>: Force and energy matching (Optional)
\n<b> One-line description </b>: 0
\n<b> Full description </b>: Choose a subset of atoms to fit forces to.  This is useful in situations where
                              it is undesirable to fit the forces on part of the system (e.g. the part that is described by another force field.)
                              Currently, you are only allowed to choose from the atoms in the front of the trajectory;
                              soon this will be expanded for random flexibility (see 'shots').  However, random coordinate selections are not allowed. ;)
\n<b> Default Value </b>: 0
\n<b> Recommendation </b>: Situation-dependent; this should be based on the part of the system that you're fitting, or leave blank
                              if you're fitting the whole system.

@li <b> FORCE </b> (Bool)
\n<b> Need to document </b>

@li <b> FORCE_CUDA </b> (Bool)
\n<b> Need to document </b>

@li <b> FORCE_MAP </b> (String)
\n<b> Need to document </b>

@li <b> FRAGMENT1 </b> (String)
\n<b> Need to document </b>

@li <b> FRAGMENT2 </b> (String)
\n<b> Need to document </b>

@li <b> GAS_EQU_STEPS </b> (Int)
\n<b> Need to document </b>

@li <b> GAS_PROD_STEPS </b> (Int)
\n<b> Need to document </b>

@li <b> HVAP_SUBAVERAGE </b> (Bool)
\n<b> Need to document </b>

@li <b> LIQUID_EQU_STEPS </b> (Int)
\n<b> Need to document </b>

@li <b> LIQUID_INTERVAL </b> (Float)
\n<b> Need to document </b>

@li <b> LIQUID_PROD_STEPS </b> (Int)
\n<b> Need to document </b>

@li <b> LIQUID_TIMESTEP </b> (Float)
\n<b> Need to document </b>

@li <b> MANUAL </b> (Bool)
\n<b> Need to document </b>

@li <b> MASTERFILE </b> (String)
\n<b> Need to document </b>

@li <b> MTS_VVVR </b> (Bool)
\n<b> Need to document </b>

@li <b> NAME </b> (String)
\n<b> Scope </b>: All targets (<b><em>Required</em></b>)
\n<b> One-line description </b>: 200
\n<b> Default Value </b>: None
\n<b> Recommendation </b>: Choose a descriptive name and make sure all targets have different names.

@li <b> OPENMM_CUDA_PRECISION </b> (String)
\n<b> Need to document </b>

@li <b> OPTIMIZE_GEOMETRY </b> (Bool)
\n<b> Need to document </b>

@li <b> POLARIZABILITY_DENOM </b> (Float)
\n<b> Need to document </b>

@li <b> QMBOLTZ </b> (Float)
\n<b> Scope </b>: Force and energy matching (Optional)
\n<b> One-line description </b>: -100
\n<b> Full description </b>: When Boltzmann sampling is used to gather snapshots for force/energy matching, there is a potential
                             ambiguity regarding which ensemble one should sample from (either the force field's ensemble or the QM calculation's
                             ensemble.  The QM ensemble may be sampled using MM-sampled snapshots by reweighting; this tuning parameter specifies
                             the fraction of QM Boltzmann weight to include.  Note that when two ensembles are different, reweighting will decrease
                             the statistical significance of the number of snapshots (i.e. there is less InfoContent).
\n<b> Default Value </b>: 0.0
\n<b> Recommendation </b>: If you want to reweight your snapshots entirely to the QM ensemble, choose 1.0; for hybrid weights,
                             use 0.5.  Avoid if the there is a very large RMS energy difference between QM and MM.

@li <b> QMBOLTZTEMP </b> (Float)
\n<b> Scope </b>: Force and energy matching (Optional)
\n<b> One-line description </b>: -100
\n<b> Full description </b>: The reweighting of an ensemble involves an exponential of (DE)/kT, so there is a massive degradation of sample
                                 quality if (DE) is large.  This option allows you to change the temperature in the denominator, which is unphysical (but
                                 it does decrease the effect of moving toward the QM ensemble.
\n<b> Default Value </b>: 298.15
\n<b> Recommendation </b>: Irrelevant if 'qmboltz' is set to zero.  Leave at the default value unless you're performing experiments.

@li <b> QUADRUPOLE_DENOM </b> (Float)
\n<b> Need to document </b>

@li <b> RESP </b> (Bool)
\n<b> Need to document </b>

@li <b> RESP_A </b> (Float)
\n<b> Need to document </b>

@li <b> RESP_B </b> (Float)
\n<b> Need to document </b>

@li <b> RMSD_DENOM </b> (Float)
\n<b> Need to document </b>

@li <b> RUN_INTERNAL </b> (Bool)
\n<b> Need to document </b>

@li <b> SAMPCORR </b> (Bool)
\n<b> Need to document </b>

@li <b> SELF_POL_ALPHA </b> (Float)
\n<b> Need to document </b>

@li <b> SELF_POL_MU0 </b> (Float)
\n<b> Need to document </b>

@li <b> SHOTS </b> (Int)
\n<b> Scope </b>: Force and energy matching (Optional)
\n<b> One-line description </b>: 0
\n<b> Full description </b>: This option allows you to choose a subset from the snapshots available in the force matching 'targets' directory.
                           The subset is simply taken from the front of the trajectory.
                           In the future this option will be expanded to allow a random selection of snapshots, or a specific selection
\n<b> Default Value </b>: -1
\n<b> Recommendation </b>: 100-10,000 snapshots are recommended.  Note that you need at least 3x (number of atoms) if
                           the covariance matrix is turned on.

@li <b> SLEEPY </b> (Int)
\n<b> Need to document </b>

@li <b> TYPE </b> (Allcap)
\n<b> Scope </b>: All targets (<b><em>Required</em></b>)
\n<b> One-line description </b>: 200
\n<b> Full description </b>: This is the type of target that you are running.  The current accepted values for the target type
                             are given in the beginning of the objective.py file: COUNTERPOISE, ABINITIO_AMBER, ABINITIO_GMX, INTERACTION_OPENMM, LIQUID_OPENMM, ABINITIO_OPENMM, ABINITIO_TINKER, BINDINGENERGY_TINKER, MONOMER_QTPIE, RDVR3_PSI4, ABINITIO_INTERNAL, MOMENTS_TINKER, THCDF_PSI4, VIBRATION_TINKER, LIQUID_TINKER, INTERACTION_TINKER.
\n<b> Default Value </b>: None
\n<b> Recommendation </b>: Choose the appropriate type, and if the target type is missing, feel free to implement your own (or ask me for help).

@li <b> W_ALPHA </b> (Float)
\n<b> Need to document </b>

@li <b> W_CP </b> (Float)
\n<b> Need to document </b>

@li <b> W_ENERGY </b> (Float)
\n<b> Need to document </b>

@li <b> W_EPS0 </b> (Float)
\n<b> Need to document </b>

@li <b> W_FORCE </b> (Float)
\n<b> Need to document </b>

@li <b> W_HVAP </b> (Float)
\n<b> Need to document </b>

@li <b> W_KAPPA </b> (Float)
\n<b> Need to document </b>

@li <b> W_NETFORCE </b> (Float)
\n<b> Need to document </b>

@li <b> W_RESP </b> (Float)
\n<b> Need to document </b>

@li <b> W_RHO </b> (Float)
\n<b> Need to document </b>

@li <b> W_TORQUE </b> (Float)
\n<b> Need to document </b>

@li <b> WAVENUMBER_TOL </b> (Float)
\n<b> Need to document </b>

@li <b> WEIGHT </b> (Float)
\n<b> Scope </b>: All target types (Optional)
\n<b> One-line description </b>: 150
\n<b> Full description </b>: This option specifies the weight that the target will contribute to the objective function.
                            A larger weight for a given target means that the optimizer will prioritize it over the others.
                            When several targets are used, the weight should be chosen carefully such that all targets
                            contribute a finite amount to the objective function.  Note that the choice of weight determines the final outcome
                            of the force field, although we hope not by too much.
\n<b> Default Value </b>: 1.0
\n<b> Recommendation </b>: It is important to specify something here (giving everything equal weight is unlikely to work.)  
                            Run a single-point objective function evaluation with all weights set to one to get a handle on
                            the natural size of each target's contribution, and then add weights accordingly.

@li <b> WHAMBOLTZ </b> (Bool)
\n<b> Scope </b>: Force and energy matching (Optional)
\n<b> One-line description </b>: -100
\n<b> Full description </b>: In self-consistent energy/force matching projects, the data from previous cycles can be reused by applying the
                               Weighted Histogram Analysis Method (WHAM).  However, the WHAM data is currently generated by external scripts that
                               haven't made it into this distribution yet.  In the future, generation of WHAM data will be incorporated into this
                               program automatically.
\n<b> Default Value </b>: 0
\n<b> Recommendation </b>: Leave off unless you have an externally generated wham-master.txt and wham-weights.txt files.

